const https = require("https");
const http = require("http");

// Configuration
const CONFIG = {
  // Replace with your actual tunnel URL
  BASE_URL: "https://smtp.pragmaticmeet.com",
  TOTAL_EMAILS: 100,
  CONCURRENT_REQUESTS: 20,
  TEST_EMAIL: "pawel.mizwa@pragmaticcoders.com", // Change to your test email
  DELAY_BETWEEN_BATCHES: 500, // 0.5 second delay between batches
};

// Test data generator
function generateTestEmail(index) {
  return {
    to: CONFIG.TEST_EMAIL,
    subject: `Stress Test Email #${index} - ${new Date().toISOString()}`,
    text: `This is stress test email number ${index}.\n\nSent at: ${new Date().toISOString()}\nTest batch: ${Math.ceil(
      index / CONFIG.CONCURRENT_REQUESTS
    )}`,
    html: `
      <h2>Stress Test Email #${index}</h2>
      <p>This is a stress test email to verify server performance.</p>
      <ul>
        <li><strong>Email Number:</strong> ${index}</li>
        <li><strong>Sent At:</strong> ${new Date().toISOString()}</li>
        <li><strong>Batch:</strong> ${Math.ceil(
          index / CONFIG.CONCURRENT_REQUESTS
        )}</li>
      </ul>
      <p><em>Generated by SMTP server stress test</em></p>
    `,
  };
}

// Function to send a single email
function sendEmail(emailData, emailIndex) {
  return new Promise((resolve) => {
    const url = new URL(`${CONFIG.BASE_URL}/send-email`);
    const postData = JSON.stringify(emailData);

    const options = {
      hostname: url.hostname,
      port: url.port || (url.protocol === "https:" ? 443 : 80),
      path: url.pathname,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData),
      },
    };

    const client = url.protocol === "https:" ? https : http;
    const startTime = Date.now();

    const req = client.request(options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        const endTime = Date.now();
        const responseTime = endTime - startTime;

        resolve({
          index: emailIndex,
          success: res.statusCode === 200,
          statusCode: res.statusCode,
          responseTime,
          response: data,
          error: null,
        });
      });
    });

    req.on("error", (error) => {
      const endTime = Date.now();
      const responseTime = endTime - startTime;

      resolve({
        index: emailIndex,
        success: false,
        statusCode: null,
        responseTime,
        response: null,
        error: error.message,
      });
    });

    req.setTimeout(30000, () => {
      req.destroy();
      resolve({
        index: emailIndex,
        success: false,
        statusCode: null,
        responseTime: 30000,
        response: null,
        error: "Request timeout",
      });
    });

    req.write(postData);
    req.end();
  });
}

// Function to send a batch of emails concurrently
async function sendBatch(startIndex, batchSize) {
  const promises = [];

  for (let i = 0; i < batchSize; i++) {
    const emailIndex = startIndex + i;
    if (emailIndex >= CONFIG.TOTAL_EMAILS) break;

    const emailData = generateTestEmail(emailIndex + 1);
    promises.push(sendEmail(emailData, emailIndex + 1));
  }

  return Promise.all(promises);
}

// Main stress test function
async function runStressTest() {
  console.log("üöÄ Starting SMTP Server Stress Test");
  console.log("=====================================");
  console.log(`Target URL: ${CONFIG.BASE_URL}`);
  console.log(`Total Emails: ${CONFIG.TOTAL_EMAILS}`);
  console.log(`Concurrent Requests: ${CONFIG.CONCURRENT_REQUESTS}`);
  console.log(`Test Email: ${CONFIG.TEST_EMAIL}`);
  console.log("=====================================\n");

  const startTime = Date.now();
  const results = {
    total: 0,
    successful: 0,
    failed: 0,
    errors: [],
    responseTimes: [],
    statusCodes: {},
  };

  const totalBatches = Math.ceil(
    CONFIG.TOTAL_EMAILS / CONFIG.CONCURRENT_REQUESTS
  );

  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
    const startIndex = batchIndex * CONFIG.CONCURRENT_REQUESTS;
    const batchSize = Math.min(
      CONFIG.CONCURRENT_REQUESTS,
      CONFIG.TOTAL_EMAILS - startIndex
    );

    console.log(
      `üì¶ Processing batch ${batchIndex + 1}/${totalBatches} (emails ${
        startIndex + 1
      }-${startIndex + batchSize})`
    );

    const batchStartTime = Date.now();
    const batchResults = await sendBatch(startIndex, batchSize);
    const batchEndTime = Date.now();

    // Process batch results
    let batchSuccessful = 0;
    let batchFailed = 0;

    batchResults.forEach((result) => {
      results.total++;
      results.responseTimes.push(result.responseTime);

      if (result.success) {
        results.successful++;
        batchSuccessful++;
      } else {
        results.failed++;
        batchFailed++;
        results.errors.push({
          email: result.index,
          error: result.error,
          statusCode: result.statusCode,
        });
      }

      // Track status codes
      const statusCode = result.statusCode || "ERROR";
      results.statusCodes[statusCode] =
        (results.statusCodes[statusCode] || 0) + 1;
    });

    const batchTime = batchEndTime - batchStartTime;
    const avgResponseTime =
      batchResults.reduce((sum, r) => sum + r.responseTime, 0) /
      batchResults.length;

    console.log(
      `   ‚úÖ Success: ${batchSuccessful}/${batchSize} | ‚ùå Failed: ${batchFailed}/${batchSize}`
    );
    console.log(
      `   ‚è±Ô∏è  Batch Time: ${batchTime}ms | Avg Response: ${avgResponseTime.toFixed(
        2
      )}ms\n`
    );

    // Delay between batches to avoid overwhelming the server
    if (batchIndex < totalBatches - 1) {
      await new Promise((resolve) =>
        setTimeout(resolve, CONFIG.DELAY_BETWEEN_BATCHES)
      );
    }
  }

  const endTime = Date.now();
  const totalTime = endTime - startTime;

  // Calculate statistics
  const avgResponseTime =
    results.responseTimes.reduce((sum, time) => sum + time, 0) /
    results.responseTimes.length;
  const minResponseTime = Math.min(...results.responseTimes);
  const maxResponseTime = Math.max(...results.responseTimes);
  const successRate = ((results.successful / results.total) * 100).toFixed(2);
  const emailsPerSecond = (results.total / (totalTime / 1000)).toFixed(2);

  // Print results
  console.log("üìä STRESS TEST RESULTS");
  console.log("======================");
  console.log(`Total Time: ${totalTime}ms (${(totalTime / 1000).toFixed(2)}s)`);
  console.log(`Emails Processed: ${results.total}`);
  console.log(`‚úÖ Successful: ${results.successful} (${successRate}%)`);
  console.log(
    `‚ùå Failed: ${results.failed} (${(100 - successRate).toFixed(2)}%)`
  );
  console.log(`üìà Throughput: ${emailsPerSecond} emails/second`);
  console.log("");
  console.log("Response Time Statistics:");
  console.log(`  Average: ${avgResponseTime.toFixed(2)}ms`);
  console.log(`  Minimum: ${minResponseTime}ms`);
  console.log(`  Maximum: ${maxResponseTime}ms`);
  console.log("");
  console.log("Status Code Distribution:");
  Object.entries(results.statusCodes).forEach(([code, count]) => {
    console.log(
      `  ${code}: ${count} (${((count / results.total) * 100).toFixed(1)}%)`
    );
  });

  if (results.errors.length > 0) {
    console.log("\n‚ùå Error Summary:");
    const errorGroups = {};
    results.errors.forEach((error) => {
      const key = error.error || `HTTP ${error.statusCode}`;
      errorGroups[key] = (errorGroups[key] || 0) + 1;
    });

    Object.entries(errorGroups).forEach(([error, count]) => {
      console.log(`  ${error}: ${count} occurrences`);
    });
  }

  console.log("\nüéØ Test completed successfully!");
}

// Run the stress test
if (require.main === module) {
  runStressTest().catch(console.error);
}

module.exports = { runStressTest };
